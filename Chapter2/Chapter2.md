# 线程安全性
线程安全的核心在于对状态访问操作进行管理，特别是对**共享**和**可变**的状态的访问。
- 共享：意味着变量可以由多个线程同时访问。
- 可变：意味着变量的值在其生命周期内可以发生变化。
------------
一个对象是否需要是线程安全，取决于它是否会被**多个线程访问**，要使对象线程安全需要采用同步机制来协同对对象可变状态的访问。
JAVA中的主要同步机制是关键字**synchronized**,他提供一种独占的加锁方式，但同步这个属于还包括**volatile类型变量**，**显示锁**（Explicit Lock）以及**原子变量**。
## 什么是线程安全
当多个线程访问某各类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都表现出正确的行为，那么就称这个类是线程安全的。
- ***无状态对象***一定是线程安全的。
当Servlet在处理请求时需要保存一些信息时，线程安全性会成为问题。
----------
## 原子性
一个操作或者多个操作，要么全部执行且执行过程中不会被任何因素打断，要么就都不执行。
在Java中，对基本数据类型变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
看下面一个例子，请分析以下哪些操作是原子性操作：
1. x = 10; //语句1
2. y = x; //语句2
3. x++; //语句3
4. x = x + 1; //语句4
-------
乍一看，上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。
语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。
语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及将x的值写入工作内存这2个操作都是原子性操作，但是合起来就不是原子性操作了。
x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。
所以上面4个语句只有语句1的操作具备原子性。
**竟态条件**和**复合操作**会引出线程安全问题。
## 加锁机制
要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。
### 内置锁
同步代码块（Synchrogazed Block）包括两部分，一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字Synchrogazed来修饰的方法就是一种横跨整个方法体的同步代码块，其中该代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。
JAVA内置锁相当于互斥体，意味着最多只有一个线程能持有锁。线程A尝试获取B持有的锁时，A必须等待或阻塞，直到B释放这个锁。如果B不释放，A将一直等待下去。
### 重入
重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响。

    private int i = 0;

	@Override
	public void run() {
		// TODO Auto-generated method stub
		get();
	}
	
	public synchronized void get() {
		i++;
		System.out.println("get"+i);
		System.out.println(Thread.currentThread().getId());
		set();
	}
	
	public synchronized void set() {
		i++;
		System.out.println("set"+i);
		System.out.println(Thread.currentThread().getId());
	}
	
	public static void main(String[] args) {
		ThreadTest threadTest = new ThreadTest();
		new Thread(threadTest).start();
		new Thread(threadTest).start();
		new Thread(threadTest).start();
	}
运行结果显示同一个线程id会被连续输出两次，i的值先由线程的get方法增加，之后由set方法增加。
## 用锁来保护状态
对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。
每个**共享**的和**可变**的变量都应该只由**一个锁**来保护，从而使维护人员知道是哪一个锁。并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。对于每个包含**多个变量**的不变性条件，其中涉及的**所有变量**都需要由**同一个锁**来保护。
## 活跃性与性能
通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性（这可能会破坏安全性）。当**执行时间较长**的计算或者可能**无法快速完成**的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。
